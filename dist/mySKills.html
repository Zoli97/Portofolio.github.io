<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="/myWork.46b18006.css">
    <link rel="stylesheet" href="/mySKills.159c180f.css">
    <link rel="stylesheet" href="/mySKills.da3073eb.css">
    <title>My skills</title>
  </head>
  <body>
    <div class="nav-container">
      <header class="header">
        <a href="/index.html">
          <img src="/logo.b3ecd760.svg" class="my_logo" alt="">
        </a>
        <!--navigation the 3 elements-->
        <nav class="navbar">
          <ul class="nav-menu" id="navbar">
            <li class="nav-item">
              <a class="nav-link nav-link-color" href="/myWork.html">My work</a>
            </li>
            <li class="nav-item">
              <a class="nav-link" href="/mySKills.html">My skills</a>
            </li>
            <li class="nav-item">
              <a class="nav-link" href="/countdown.html">Hire me</a>
            </li>
            <li class="nav-item">
              <a class="nav-link" href="/contact.html">Contact</a>
            </li>
          </ul>

          <div class="hamburger">
            <span class="bar"></span>
            <span class="bar"></span>
            <span class="bar"></span>
          </div>
        </nav>
      </header>
    </div>

    <section class="section1">
      <article class="article1">
        <h1 class="title rellax" data-rellax-speed="6" data-rellax-mobile-speed="4" data-rellax-tablet-speed="3" data-rellax-percentage="0.2">
          Gallery * <br><span class="sub-title rellax" data-rellax-speed="6" data-rellax-mobile-speed="4" data-rellax-tablet-speed="3" data-rellax-percentage="0.8">Explore some cool stuff <br>
            on this page.</span>
        </h1>
        <div class="circle arrow-down">
          <a href="#section2">
            <svg class="arrow-down" fill="none" height="70" viewbox="0 0 155 150" width="70" xmlns="http://www.w3.org/2000/svg">
              <path d="M3.49704 54.1884C-3.29737 80.8928 2.65228 104.451 21.1932 124.216C21.6762 124.727 22.1678 125.238 22.6601 125.729C32.6193 135.689 45.0248 141.838 54.8548 146.118C59.073 147.96 80.721 150.197 86.5775 149.325C121.385 144.127 144.291 124.495 152.269 91.6509C153.793 85.2172 154.551 78.626 154.53 72.0145C154.567 56.4389 148.009 38.3319 134.485 24.7713C133.093 23.6201 131.705 22.4276 130.364 21.2718C127.454 18.7705 124.446 16.1806 121.3 13.9713C97.2641 -2.94511 72.2911 -3.03962 47.0759 5.9312C24.2471 14.0481 9.58786 30.2872 3.49704 54.1884ZM47.1736 13.9273C69.2975 4.73395 91.4955 3.11148 113.145 16.8808C117.104 19.4011 127.658 27.931 129.32 29.2121L129.427 29.2908L129.515 29.3881C137.961 38.3458 147.633 54.7227 147.419 71.5591C147.349 78.7578 146.375 85.9192 144.519 92.875C139.019 112.864 125.871 127.432 104.323 137.396C82.4177 147.885 51.0027 137.281 42.6442 131.764C33.4055 125.448 25.3218 117.59 18.7464 108.534C8.43402 93.9329 6.11974 72.9466 11.6579 53.7612C14.2518 44.9025 18.7845 36.7321 24.9274 29.8423C31.0703 22.9526 38.6693 17.5161 47.1736 13.9273Z" fill="white"></path>
              <path d="M47.4534 89.0431C47.4411 89.5591 47.5903 90.0659 47.88 90.493C48.3265 90.9666 48.8215 91.3921 49.3568 91.7624C49.7607 92.0486 50.1452 92.3615 50.5074 92.699C53.3165 95.4455 56.1199 98.1982 58.9177 100.957C62.5494 104.531 66.1877 108.098 69.8326 111.659C71.3542 113.241 73.0296 114.667 74.8339 115.918C75.8222 116.622 76.9947 117.023 78.2075 117.071C79.6409 117.071 81.0336 116.389 82.5321 115.011C85.0563 112.689 87.7906 110.257 90.8905 107.577C93.1474 105.626 95.4127 103.684 97.6862 101.751C100.149 99.6509 102.606 97.5426 105.058 95.4261C106.044 94.6177 106.906 93.6698 107.618 92.6123C108.015 91.9789 108.066 90.6112 107.574 90.0802C107.225 89.7888 106.806 89.5925 106.359 89.5104C105.911 89.4283 105.45 89.4631 105.02 89.6115C103.971 90.1837 102.983 90.8626 102.073 91.6371C101.857 91.8077 101.643 91.979 101.426 92.1463C98.2848 94.5827 95.1456 97.021 92.0083 99.4612C88.3511 102.305 84.6927 105.146 81.0329 107.984C80.7071 108.218 80.3625 108.424 80.0025 108.6L79.7472 108.737C79.8242 107.169 79.9021 105.626 79.9809 104.108C80.1725 100.353 80.3537 96.8056 80.4915 93.2089C80.7836 85.5671 81.0671 74.4042 81.3408 63.6081C81.5777 54.315 81.8002 45.5372 82.0227 39.0906C82.0548 37.8272 81.9654 36.5636 81.7556 35.3173C81.4537 33.414 80.4751 32.4497 78.8467 32.4497H78.8434C77.0241 32.4497 75.9221 33.5288 75.7409 35.484C75.691 36.0226 75.6392 36.5624 75.5854 37.1032C75.3681 39.321 75.1437 41.6136 75.1141 43.8786C74.9966 52.915 74.9054 65.7071 74.8168 78.0738C74.7512 87.6564 74.6855 96.7066 74.61 103.642C74.5917 104.147 74.5411 104.649 74.4584 105.147C74.4433 105.257 74.4269 105.37 74.4112 105.487L73.9308 105.044C73.4011 104.556 72.9607 104.15 72.5367 103.727C66.4332 97.734 59.4365 92.7249 51.7964 88.8784L51.5621 88.7563C50.9001 88.3757 50.195 88.0756 49.4618 87.8623C49.027 87.7924 48.5819 87.8223 48.1603 87.9497C47.9903 87.9877 47.8209 88.0259 47.6549 88.0489L47.3103 88.0955L47.376 88.4374C47.412 88.6379 47.4378 88.84 47.4534 89.0431Z" fill="white"></path>
            </svg>
          </a>
        </div>
      </article>
    </section>
    <hr class="line">

    <section class="section2" id="section2">
      <article class="article2 rellax" data-rellax-speed="6" data-rellax-mobile-speed="5" data-rellax-tablet-speed="4" data-rellax-percentage="0.3">
        <img src="/me.0f438621.jpg" alt="">
      </article>

      <article class="article3">
        <p class="text rellax" data-rellax-speed="1" data-rellax-mobile-speed="3" data-rellax-tablet-speed="2" data-rellax-percentage="0.3" data-rellax-zindex="-5">
          IT'S ALL ABOUT TIME AND THINK POSITIVE, BEATIFUL THINGS <br>
          HAPPEN WHEN YOU DISTANCE YOURSELF <br>
          FROM NEGATIVITY.
        </p>

        <p class="text text2">
          IF YOU CONTINUE TO WATCH THIS PAGE PLEASE GO DOWN <br>
          FOR MORE CONTENT LIKE THIS, I KNOW YOU LIKE THAT <br>
          JUST DON'T STOP FROM SCROLLING DOWN.
        </p>

        <svg class="arrow" width="71" height="24" viewbox="0 0 71 24" fill="none" xmlns="http://www.w3.org/2000/svg">
          <path d="M70.0607 13.0607C70.6464 12.4749 70.6464 11.5251 70.0607 10.9393L60.5147 1.3934C59.9289 0.807612 58.9792 0.807612 58.3934 1.3934C57.8076 1.97918 57.8076 2.92893 58.3934 3.51472L66.8787 12L58.3934 20.4853C57.8076 21.0711 57.8076 22.0208 58.3934 22.6066C58.9792 23.1924 59.9289 23.1924 60.5147 22.6066L70.0607 13.0607ZM0 13.5H69V10.5H0V13.5Z" fill="white"></path>
        </svg>
      </article>
    </section>
    <hr>

    <section class="section3">
      <article class="article3">
        <p class="text text2 align-text my-text" data-scroll="">
          NO DESCRIPTION NEED TO THIS IMAGE, I KNOW TAKE TIME <br>
          FOR YOU TO UNDERTAND THIS WHOLE GALLERY <br>
          BUT FOR THE MOMENT ENJOY THIS AND <br>
          PLEASE SCROLL DOWN FOR MORE..
        </p>
        <button class="btn">
          <svg class="same_arrow" width="71" height="24" viewbox="0 0 71 24" fill="none" xmlns="http://www.w3.org/2000/svg">
            <path d="M70.0607 13.0607C70.6464 12.4749 70.6464 11.5251 70.0607 10.9393L60.5147 1.3934C59.9289 0.807612 58.9792 0.807612 58.3934 1.3934C57.8076 1.97918 57.8076 2.92893 58.3934 3.51472L66.8787 12L58.3934 20.4853C57.8076 21.0711 57.8076 22.0208 58.3934 22.6066C58.9792 23.1924 59.9289 23.1924 60.5147 22.6066L70.0607 13.0607ZM0 13.5H69V10.5H0V13.5Z" fill="white"></path>
          </svg>
        </button>
      </article>
      <article class="article4">
        <img src="/mee.17520502.jpg" alt="" class="img" data-scroll="">
      </article>
    </section>

    <hr>

    <section class="section4">
      <article class="article4" id="lightgallery">
        <img src="/me3.29dc5421.jpg" alt="pic" class="card-img">
        <img src="/me4.d6e49eaa.jpg" alt="pic" class="card-img1">
        <img src="/me5.8e9191c8.jpg" alt="pic" class="card-img2">
      </article>
    </section>

    <hr>

    <div class="copyright">
      <p class="copyright_text">&copy; Copyright Tazlo Zoli 2021</p>
    </div>

    <script src="/mySKills.be2ce8a8.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/dixonandmoe/rellax@master/rellax.min.js"></script>
    <script src="https://unpkg.com/scroll-out/dist/scroll-out.min.js"></script>

    <script src="/mySKills.24ca2391.js" defer=""></script>
    <script>// modules are defined as an array
// [ module function, map of requires ]
//
// map of requires is short require name -> numeric require
//
// anything defined in a previous bundle is accessed via the
// orig method which is the require for previous bundles

(function (modules, entry, mainEntry, parcelRequireName, globalName) {
  /* eslint-disable no-undef */
  var globalObject =
    typeof globalThis !== 'undefined'
      ? globalThis
      : typeof self !== 'undefined'
      ? self
      : typeof window !== 'undefined'
      ? window
      : typeof global !== 'undefined'
      ? global
      : {};
  /* eslint-enable no-undef */

  // Save the require from previous bundle to this closure if any
  var previousRequire =
    typeof globalObject[parcelRequireName] === 'function' &&
    globalObject[parcelRequireName];

  var cache = previousRequire.cache || {};
  // Do not use `require` to prevent Webpack from trying to bundle this call
  var nodeRequire =
    typeof module !== 'undefined' &&
    typeof module.require === 'function' &&
    module.require.bind(module);

  function newRequire(name, jumped) {
    if (!cache[name]) {
      if (!modules[name]) {
        // if we cannot find the module within our internal map or
        // cache jump to the current global require ie. the last bundle
        // that was added to the page.
        var currentRequire =
          typeof globalObject[parcelRequireName] === 'function' &&
          globalObject[parcelRequireName];
        if (!jumped && currentRequire) {
          return currentRequire(name, true);
        }

        // If there are other bundles on this page the require from the
        // previous one is saved to 'previousRequire'. Repeat this as
        // many times as there are bundles until the module is found or
        // we exhaust the require chain.
        if (previousRequire) {
          return previousRequire(name, true);
        }

        // Try the node require function if it exists.
        if (nodeRequire && typeof name === 'string') {
          return nodeRequire(name);
        }

        var err = new Error("Cannot find module '" + name + "'");
        err.code = 'MODULE_NOT_FOUND';
        throw err;
      }

      localRequire.resolve = resolve;
      localRequire.cache = {};

      var module = (cache[name] = new newRequire.Module(name));

      modules[name][0].call(
        module.exports,
        localRequire,
        module,
        module.exports,
        this
      );
    }

    return cache[name].exports;

    function localRequire(x) {
      var res = localRequire.resolve(x);
      return res === false ? {} : newRequire(res);
    }

    function resolve(x) {
      var id = modules[name][1][x];
      return id != null ? id : x;
    }
  }

  function Module(moduleName) {
    this.id = moduleName;
    this.bundle = newRequire;
    this.exports = {};
  }

  newRequire.isParcelRequire = true;
  newRequire.Module = Module;
  newRequire.modules = modules;
  newRequire.cache = cache;
  newRequire.parent = previousRequire;
  newRequire.register = function (id, exports) {
    modules[id] = [
      function (require, module) {
        module.exports = exports;
      },
      {},
    ];
  };

  Object.defineProperty(newRequire, 'root', {
    get: function () {
      return globalObject[parcelRequireName];
    },
  });

  globalObject[parcelRequireName] = newRequire;

  for (var i = 0; i < entry.length; i++) {
    newRequire(entry[i]);
  }

  if (mainEntry) {
    // Expose entry point to Node, AMD or browser globals
    // Based on https://github.com/ForbesLindesay/umd/blob/master/template.js
    var mainExports = newRequire(mainEntry);

    // CommonJS
    if (typeof exports === 'object' && typeof module !== 'undefined') {
      module.exports = mainExports;

      // RequireJS
    } else if (typeof define === 'function' && define.amd) {
      define(function () {
        return mainExports;
      });

      // <script>
    } else if (globalName) {
      this[globalName] = mainExports;
    }
  }
})({"b0pxd":[function(require,module,exports) {
"use strict";
var global = arguments[3];
var HMR_HOST = null;
var HMR_PORT = null;
var HMR_SECURE = false;
var HMR_ENV_HASH = "d6ea1d42532a7575";
module.bundle.HMR_BUNDLE_ID = "9d1363e98a5acee1";
/* global HMR_HOST, HMR_PORT, HMR_ENV_HASH, HMR_SECURE, chrome, browser, globalThis, __parcel__import__, __parcel__importScripts__, ServiceWorkerGlobalScope */ /*::
import type {
  HMRAsset,
  HMRMessage,
} from '@parcel/reporter-dev-server/src/HMRServer.js';
interface ParcelRequire {
  (string): mixed;
  cache: {|[string]: ParcelModule|};
  hotData: mixed;
  Module: any;
  parent: ?ParcelRequire;
  isParcelRequire: true;
  modules: {|[string]: [Function, {|[string]: string|}]|};
  HMR_BUNDLE_ID: string;
  root: ParcelRequire;
}
interface ParcelModule {
  hot: {|
    data: mixed,
    accept(cb: (Function) => void): void,
    dispose(cb: (mixed) => void): void,
    // accept(deps: Array<string> | string, cb: (Function) => void): void,
    // decline(): void,
    _acceptCallbacks: Array<(Function) => void>,
    _disposeCallbacks: Array<(mixed) => void>,
  |};
}
interface ExtensionContext {
  runtime: {|
    reload(): void,
    getURL(url: string): string;
    getManifest(): {manifest_version: number, ...};
  |};
}
declare var module: {bundle: ParcelRequire, ...};
declare var HMR_HOST: string;
declare var HMR_PORT: string;
declare var HMR_ENV_HASH: string;
declare var HMR_SECURE: boolean;
declare var chrome: ExtensionContext;
declare var browser: ExtensionContext;
declare var __parcel__import__: (string) => Promise<void>;
declare var __parcel__importScripts__: (string) => Promise<void>;
declare var globalThis: typeof self;
declare var ServiceWorkerGlobalScope: Object;
*/ var OVERLAY_ID = "__parcel__error__overlay__";
var OldModule = module.bundle.Module;
function Module(moduleName) {
    OldModule.call(this, moduleName);
    this.hot = {
        data: module.bundle.hotData,
        _acceptCallbacks: [],
        _disposeCallbacks: [],
        accept: function(fn) {
            this._acceptCallbacks.push(fn || function() {});
        },
        dispose: function(fn) {
            this._disposeCallbacks.push(fn);
        }
    };
    module.bundle.hotData = undefined;
}
module.bundle.Module = Module;
var checkedAssets, acceptedAssets, assetsToAccept /*: Array<[ParcelRequire, string]> */ ;
function getHostname() {
    return HMR_HOST || (location.protocol.indexOf("http") === 0 ? location.hostname : "localhost");
}
function getPort() {
    return HMR_PORT || location.port;
} // eslint-disable-next-line no-redeclare
var parent = module.bundle.parent;
if ((!parent || !parent.isParcelRequire) && typeof WebSocket !== "undefined") {
    var hostname = getHostname();
    var port = getPort();
    var protocol = HMR_SECURE || location.protocol == "https:" && !/localhost|127.0.0.1|0.0.0.0/.test(hostname) ? "wss" : "ws";
    var ws = new WebSocket(protocol + "://" + hostname + (port ? ":" + port : "") + "/"); // Web extension context
    var extCtx = typeof chrome === "undefined" ? typeof browser === "undefined" ? null : browser : chrome; // Safari doesn't support sourceURL in error stacks.
    // eval may also be disabled via CSP, so do a quick check.
    var supportsSourceURL = false;
    try {
        (0, eval)('throw new Error("test"); //# sourceURL=test.js');
    } catch (err) {
        supportsSourceURL = err.stack.includes("test.js");
    } // $FlowFixMe
    ws.onmessage = async function(event) {
        checkedAssets = {} /*: {|[string]: boolean|} */ ;
        acceptedAssets = {} /*: {|[string]: boolean|} */ ;
        assetsToAccept = [];
        var data = JSON.parse(event.data);
        if (data.type === "update") {
            // Remove error overlay if there is one
            if (typeof document !== "undefined") removeErrorOverlay();
            let assets = data.assets.filter((asset)=>asset.envHash === HMR_ENV_HASH); // Handle HMR Update
            let handled = assets.every((asset)=>{
                return asset.type === "css" || asset.type === "js" && hmrAcceptCheck(module.bundle.root, asset.id, asset.depsByBundle);
            });
            if (handled) {
                console.clear(); // Dispatch custom event so other runtimes (e.g React Refresh) are aware.
                if (typeof window !== "undefined" && typeof CustomEvent !== "undefined") window.dispatchEvent(new CustomEvent("parcelhmraccept"));
                await hmrApplyUpdates(assets);
                for(var i = 0; i < assetsToAccept.length; i++){
                    var id = assetsToAccept[i][1];
                    if (!acceptedAssets[id]) hmrAcceptRun(assetsToAccept[i][0], id);
                }
            } else fullReload();
        }
        if (data.type === "error") {
            // Log parcel errors to console
            for (let ansiDiagnostic of data.diagnostics.ansi){
                let stack = ansiDiagnostic.codeframe ? ansiDiagnostic.codeframe : ansiDiagnostic.stack;
                console.error("\uD83D\uDEA8 [parcel]: " + ansiDiagnostic.message + "\n" + stack + "\n\n" + ansiDiagnostic.hints.join("\n"));
            }
            if (typeof document !== "undefined") {
                // Render the fancy html overlay
                removeErrorOverlay();
                var overlay = createErrorOverlay(data.diagnostics.html); // $FlowFixMe
                document.body.appendChild(overlay);
            }
        }
    };
    ws.onerror = function(e) {
        console.error(e.message);
    };
    ws.onclose = function() {
        console.warn("[parcel] \uD83D\uDEA8 Connection to the HMR server was lost");
    };
}
function removeErrorOverlay() {
    var overlay = document.getElementById(OVERLAY_ID);
    if (overlay) {
        overlay.remove();
        console.log("[parcel] ‚ú® Error resolved");
    }
}
function createErrorOverlay(diagnostics) {
    var overlay = document.createElement("div");
    overlay.id = OVERLAY_ID;
    let errorHTML = '<div style="background: black; opacity: 0.85; font-size: 16px; color: white; position: fixed; height: 100%; width: 100%; top: 0px; left: 0px; padding: 30px; font-family: Menlo, Consolas, monospace; z-index: 9999;">';
    for (let diagnostic of diagnostics){
        let stack = diagnostic.frames.length ? diagnostic.frames.reduce((p, frame)=>{
            return `${p}
<a href="/__parcel_launch_editor?file=${encodeURIComponent(frame.location)}" style="text-decoration: underline; color: #888" onclick="fetch(this.href); return false">${frame.location}</a>
${frame.code}`;
        }, "") : diagnostic.stack;
        errorHTML += `
      <div>
        <div style="font-size: 18px; font-weight: bold; margin-top: 20px;">
          üö® ${diagnostic.message}
        </div>
        <pre>${stack}</pre>
        <div>
          ${diagnostic.hints.map((hint)=>"<div>\uD83D\uDCA1 " + hint + "</div>").join("")}
        </div>
        ${diagnostic.documentation ? `<div>üìù <a style="color: violet" href="${diagnostic.documentation}" target="_blank">Learn more</a></div>` : ""}
      </div>
    `;
    }
    errorHTML += "</div>";
    overlay.innerHTML = errorHTML;
    return overlay;
}
function fullReload() {
    if ("reload" in location) location.reload();
    else if (extCtx && extCtx.runtime && extCtx.runtime.reload) extCtx.runtime.reload();
}
function getParents(bundle, id) /*: Array<[ParcelRequire, string]> */ {
    var modules = bundle.modules;
    if (!modules) return [];
    var parents = [];
    var k, d, dep;
    for(k in modules)for(d in modules[k][1]){
        dep = modules[k][1][d];
        if (dep === id || Array.isArray(dep) && dep[dep.length - 1] === id) parents.push([
            bundle,
            k
        ]);
    }
    if (bundle.parent) parents = parents.concat(getParents(bundle.parent, id));
    return parents;
}
function updateLink(link) {
    var newLink = link.cloneNode();
    newLink.onload = function() {
        if (link.parentNode !== null) // $FlowFixMe
        link.parentNode.removeChild(link);
    };
    newLink.setAttribute("href", link.getAttribute("href").split("?")[0] + "?" + Date.now()); // $FlowFixMe
    link.parentNode.insertBefore(newLink, link.nextSibling);
}
var cssTimeout = null;
function reloadCSS() {
    if (cssTimeout) return;
    cssTimeout = setTimeout(function() {
        var links = document.querySelectorAll('link[rel="stylesheet"]');
        for(var i = 0; i < links.length; i++){
            // $FlowFixMe[incompatible-type]
            var href = links[i].getAttribute("href");
            var hostname = getHostname();
            var servedFromHMRServer = hostname === "localhost" ? new RegExp("^(https?:\\/\\/(0.0.0.0|127.0.0.1)|localhost):" + getPort()).test(href) : href.indexOf(hostname + ":" + getPort());
            var absolute = /^https?:\/\//i.test(href) && href.indexOf(location.origin) !== 0 && !servedFromHMRServer;
            if (!absolute) updateLink(links[i]);
        }
        cssTimeout = null;
    }, 50);
}
function hmrDownload(asset) {
    if (asset.type === "js") {
        if (typeof document !== "undefined") {
            let script = document.createElement("script");
            script.src = asset.url + "?t=" + Date.now();
            if (asset.outputFormat === "esmodule") script.type = "module";
            return new Promise((resolve, reject)=>{
                var _document$head;
                script.onload = ()=>resolve(script);
                script.onerror = reject;
                (_document$head = document.head) === null || _document$head === void 0 || _document$head.appendChild(script);
            });
        } else if (typeof importScripts === "function") {
            // Worker scripts
            if (asset.outputFormat === "esmodule") return import(asset.url + "?t=" + Date.now());
            else return new Promise((resolve, reject)=>{
                try {
                    importScripts(asset.url + "?t=" + Date.now());
                    resolve();
                } catch (err) {
                    reject(err);
                }
            });
        }
    }
}
async function hmrApplyUpdates(assets) {
    global.parcelHotUpdate = Object.create(null);
    let scriptsToRemove;
    try {
        // If sourceURL comments aren't supported in eval, we need to load
        // the update from the dev server over HTTP so that stack traces
        // are correct in errors/logs. This is much slower than eval, so
        // we only do it if needed (currently just Safari).
        // https://bugs.webkit.org/show_bug.cgi?id=137297
        // This path is also taken if a CSP disallows eval.
        if (!supportsSourceURL) {
            let promises = assets.map((asset)=>{
                var _hmrDownload;
                return (_hmrDownload = hmrDownload(asset)) === null || _hmrDownload === void 0 ? void 0 : _hmrDownload.catch((err)=>{
                    // Web extension bugfix for Chromium
                    // https://bugs.chromium.org/p/chromium/issues/detail?id=1255412#c12
                    if (extCtx && extCtx.runtime && extCtx.runtime.getManifest().manifest_version == 3) {
                        if (typeof ServiceWorkerGlobalScope != "undefined" && global instanceof ServiceWorkerGlobalScope) {
                            extCtx.runtime.reload();
                            return;
                        }
                        asset.url = extCtx.runtime.getURL("/__parcel_hmr_proxy__?url=" + encodeURIComponent(asset.url + "?t=" + Date.now()));
                        return hmrDownload(asset);
                    }
                    throw err;
                });
            });
            scriptsToRemove = await Promise.all(promises);
        }
        assets.forEach(function(asset) {
            hmrApply(module.bundle.root, asset);
        });
    } finally{
        delete global.parcelHotUpdate;
        if (scriptsToRemove) scriptsToRemove.forEach((script)=>{
            if (script) {
                var _document$head2;
                (_document$head2 = document.head) === null || _document$head2 === void 0 || _document$head2.removeChild(script);
            }
        });
    }
}
function hmrApply(bundle, asset) {
    var modules = bundle.modules;
    if (!modules) return;
    if (asset.type === "css") reloadCSS();
    else if (asset.type === "js") {
        let deps = asset.depsByBundle[bundle.HMR_BUNDLE_ID];
        if (deps) {
            if (modules[asset.id]) {
                // Remove dependencies that are removed and will become orphaned.
                // This is necessary so that if the asset is added back again, the cache is gone, and we prevent a full page reload.
                let oldDeps = modules[asset.id][1];
                for(let dep in oldDeps)if (!deps[dep] || deps[dep] !== oldDeps[dep]) {
                    let id = oldDeps[dep];
                    let parents = getParents(module.bundle.root, id);
                    if (parents.length === 1) hmrDelete(module.bundle.root, id);
                }
            }
            if (supportsSourceURL) // Global eval. We would use `new Function` here but browser
            // support for source maps is better with eval.
            (0, eval)(asset.output);
             // $FlowFixMe
            let fn = global.parcelHotUpdate[asset.id];
            modules[asset.id] = [
                fn,
                deps
            ];
        } else if (bundle.parent) hmrApply(bundle.parent, asset);
    }
}
function hmrDelete(bundle, id) {
    let modules = bundle.modules;
    if (!modules) return;
    if (modules[id]) {
        // Collect dependencies that will become orphaned when this module is deleted.
        let deps = modules[id][1];
        let orphans = [];
        for(let dep in deps){
            let parents = getParents(module.bundle.root, deps[dep]);
            if (parents.length === 1) orphans.push(deps[dep]);
        } // Delete the module. This must be done before deleting dependencies in case of circular dependencies.
        delete modules[id];
        delete bundle.cache[id]; // Now delete the orphans.
        orphans.forEach((id)=>{
            hmrDelete(module.bundle.root, id);
        });
    } else if (bundle.parent) hmrDelete(bundle.parent, id);
}
function hmrAcceptCheck(bundle, id, depsByBundle) {
    if (hmrAcceptCheckOne(bundle, id, depsByBundle)) return true;
     // Traverse parents breadth first. All possible ancestries must accept the HMR update, or we'll reload.
    let parents = getParents(module.bundle.root, id);
    let accepted = false;
    while(parents.length > 0){
        let v = parents.shift();
        let a = hmrAcceptCheckOne(v[0], v[1], null);
        if (a) // If this parent accepts, stop traversing upward, but still consider siblings.
        accepted = true;
        else {
            // Otherwise, queue the parents in the next level upward.
            let p = getParents(module.bundle.root, v[1]);
            if (p.length === 0) {
                // If there are no parents, then we've reached an entry without accepting. Reload.
                accepted = false;
                break;
            }
            parents.push(...p);
        }
    }
    return accepted;
}
function hmrAcceptCheckOne(bundle, id, depsByBundle) {
    var modules = bundle.modules;
    if (!modules) return;
    if (depsByBundle && !depsByBundle[bundle.HMR_BUNDLE_ID]) {
        // If we reached the root bundle without finding where the asset should go,
        // there's nothing to do. Mark as "accepted" so we don't reload the page.
        if (!bundle.parent) return true;
        return hmrAcceptCheck(bundle.parent, id, depsByBundle);
    }
    if (checkedAssets[id]) return true;
    checkedAssets[id] = true;
    var cached = bundle.cache[id];
    assetsToAccept.push([
        bundle,
        id
    ]);
    if (!cached || cached.hot && cached.hot._acceptCallbacks.length) return true;
}
function hmrAcceptRun(bundle, id) {
    var cached = bundle.cache[id];
    bundle.hotData = {};
    if (cached && cached.hot) cached.hot.data = bundle.hotData;
    if (cached && cached.hot && cached.hot._disposeCallbacks.length) cached.hot._disposeCallbacks.forEach(function(cb) {
        cb(bundle.hotData);
    });
    delete bundle.cache[id];
    bundle(id);
    cached = bundle.cache[id];
    if (cached && cached.hot && cached.hot._acceptCallbacks.length) cached.hot._acceptCallbacks.forEach(function(cb) {
        var assetsToAlsoAccept = cb(function() {
            return getParents(module.bundle.root, id);
        });
        if (assetsToAlsoAccept && assetsToAccept.length) // $FlowFixMe[method-unbinding]
        assetsToAccept.push.apply(assetsToAccept, assetsToAlsoAccept);
    });
    acceptedAssets[id] = true;
}

},{}],"5giev":[function(require,module,exports) {
ScrollOut({
    threshold: 0.5,
    targets: ".img, .my-text, .card-img, .card-img1, .card-img2"
});

},{}]},["b0pxd","5giev"], "5giev", "parcelRequiree693")

</script>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/lightgallery/2.7.0/lightgallery.min.js" integrity="sha512-pG+XpUdyBtp28FzjpaIaj72KYvZ87ZbmB3iytDK5+WFVyun8r5LJ2x1/Jy/KHdtzUXA0CUVhEnG+Isy1jVJAbA==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>

    <script>const light_gallery = document.getElementById("lightgallery");
lightGallery(light_gallery, {
    speed: 400,
    mode: "lg-fade",
    showMaximizeIcon: true
});

</script>

    <script>var docWidth = document.documentElement.offsetWidth;
[].forEach.call(document.querySelectorAll("*"), function(el) {
    if (el.offsetWidth > docWidth) console.log(el);
});
//need to know how tall is the navbar, so now i can use this now to update or apply to html
const scrollHeight = document.querySelector(".nav-container").offsetHeight;
console.log(scrollHeight);
console.log(document.documentElement);
//set custom prop
document.documentElement.style.setProperty("--scroll-top", scrollHeight + "px");

</script>
  </body>
</html>
